// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package apiserver

import (
	"github.com/spf13/pflag"
	"velda.io/velda/pkg/broker"
	"velda.io/velda/pkg/proto"
)

import (
	_ "net/http/pprof"
	_ "velda.io/velda/pkg/broker/backends/registry"
)

// Injectors from wire.go:

func RunAllService(flag *pflag.FlagSet) (CompletionError, error) {
	serverMetrics := ProvideGrpcMetrics()
	serverAuthUnaryInterceptor := _wireServerAuthUnaryInterceptorValue
	serverAuthStreamInterceptor := _wireServerAuthStreamInterceptorValue
	server := ProvideGrpcServer(serverMetrics, serverAuthUnaryInterceptor, serverAuthStreamInterceptor)
	serveMux := ProvideHttpHandler()
	runtimeServeMux := ProvideGrpcMux(serveMux)
	serviceCtx := ProvideBaseCtx()
	context := ProvideCtx(serviceCtx)
	configPath := ProvideConfigPath(flag)
	config, err := ProvideConfig(configPath)
	if err != nil {
		return nil, err
	}
	brokerInfo := ProvideBrokerInfo(context, config)
	schedulerSet, err := ProvideSchedulers(context, config, brokerInfo)
	if err != nil {
		return nil, err
	}
	sessionCompletionWatcher := _wireNullCompletionWatcherValue
	watcher := broker.NewWatcher()
	sessionHelper := ProvideSessionHelper(sessionCompletionWatcher, watcher)
	sessionDatabase := broker.NewSessionDatabase(sessionHelper)
	permissions := ProvidePermission()
	storage, err := ProvideStorage(config)
	if err != nil {
		return nil, err
	}
	apiserverDatabase, err := ProvideDb(storage, context)
	if err != nil {
		return nil, err
	}
	provisionRunner, err := ProvideProvisioners(context, config, schedulerSet, brokerInfo)
	if err != nil {
		return nil, err
	}
	regionId := ProvideRegionId()
	taskTracker := ProvideTaskTracker(config, context, schedulerSet, sessionDatabase, apiserverDatabase, provisionRunner, watcher, regionId)
	localDiskProvider := ProvideLocalDiskStorage(storage)
	nfsExportAuth, err := broker.NewNfsExportAuth(localDiskProvider)
	if err != nil {
		return nil, err
	}
	brokerAuth := NewBrokerAuth(nfsExportAuth)
	brokerServiceServer := ProvideBrokerServer(server, runtimeServeMux, schedulerSet, sessionDatabase, permissions, taskTracker, brokerAuth, apiserverDatabase)
	taskLogDb := ProvideTaskLogDb(storage)
	taskServiceServer := ProvideTaskService(context, server, runtimeServeMux, apiserverDatabase, taskLogDb, taskTracker, permissions)
	poolManagerServiceServer := ProvidePoolService(server, runtimeServeMux, schedulerSet)
	instanceServiceServer := ProvideInstanceService(server, runtimeServeMux, apiserverDatabase, storage, permissions)
	registry := _wireRegistryValue
	metricRegistryRunner := ProvideMetrics(registry, serverMetrics)
	grpcRunner, err := ProvideGrpcRunner(serviceCtx, config, server)
	if err != nil {
		return nil, err
	}
	httpRunner, err := ProvideHttpRunner(serviceCtx, config, serveMux)
	if err != nil {
		return nil, err
	}
	readyFd := ProvideReadyFd(flag)
	readySignalRunner := ProvideReadySignal(readyFd)
	v := ProvideRunners(brokerServiceServer, taskServiceServer, poolManagerServiceServer, instanceServiceServer, metricRegistryRunner, provisionRunner, grpcRunner, httpRunner, readySignalRunner)
	completionError := ProvideCompletionSignal(v, serviceCtx)
	return completionError, nil
}

var (
	_wireServerAuthUnaryInterceptorValue  = ServerAuthUnaryInterceptor(sessionInterceptor)
	_wireServerAuthStreamInterceptorValue = ServerAuthStreamInterceptor(sessionStreamInterceptor)
	_wireNullCompletionWatcherValue       = &broker.NullCompletionWatcher{}
	_wireRegistryValue                    = AllMetrics
)

// wire.go:

func ProvideRunners(
	_ proto.BrokerServiceServer,
	_ proto.TaskServiceServer,
	_ proto.PoolManagerServiceServer,
	_ proto.InstanceServiceServer,
	metrics MetricRegistryRunner,
	provisioners ProvisionRunner,
	grpcRunner GrpcRunner,
	httpRunner HttpRunner,
	ready ReadySignalRunner,
) []Runner {
	return []Runner{
		Runner(metrics),
		Runner(provisioners),
		Runner(httpRunner),
		Runner(grpcRunner),
		Runner(ready),
	}
}
