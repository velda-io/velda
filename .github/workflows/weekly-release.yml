name: Weekly Release

on:
  # Automated weekly release every Monday at 9:00 AM UTC
  schedule:
    - cron: '0 9 * * 1'
  
  # Manual trigger with optional inputs
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to release from (e.g. v1.2). If empty uses the workflow run branch.'
        required: false
        default: ''
      variant:
        description: 'Release variant (e.g. test, alpha, beta). Empty = prod.'
        required: false
        default: ''
      skip_if_no_changes:
        description: 'Skip release if no commits since last release'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: write

jobs:
  weekly_release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Configure git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Determine source branch
        id: branch
        shell: bash
        env:
          INPUT_BRANCH: ${{ github.event.inputs.branch }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
        run: |
          if [ -n "$INPUT_BRANCH" ]; then
            src_ref="$INPUT_BRANCH"
          else
            src_ref="$GITHUB_REF_NAME"
          fi
          echo "source_ref=$src_ref" >> "$GITHUB_OUTPUT"
          echo "Source branch: $src_ref"

      - name: Validate branch format
        shell: bash
        env:
          SRC_REF: ${{ steps.branch.outputs.source_ref }}
        run: |
          if [[ ! "$SRC_REF" =~ ^v[0-9]+\.[0-9]+$ ]]; then
            echo "Branch '$SRC_REF' does not match v<major>.<minor> format. Aborting."
            exit 1
          fi

      - name: Fetch all tags
        run: git fetch --tags --prune

      - name: Calculate next version
        id: version
        shell: bash
        env:
          BASE: ${{ steps.branch.outputs.source_ref }}
          VARIANT: ${{ github.event.inputs.variant }}
        run: |
          set -euo pipefail
          
          # Find latest prod tag (no suffix) for this base: v<major>.<minor>.<patch>
          prod_latest_tag=$(git tag --list "${BASE}.*" | grep -E "^${BASE}\.[0-9]+$" | sort -V | tail -n1 || true)
          
          if [ -z "$prod_latest_tag" ]; then
            prod_next_patch=0
            echo "last_tag=" >> "$GITHUB_OUTPUT"
          else
            prod_patch=${prod_latest_tag##*.}
            prod_next_patch=$((prod_patch + 1))
            echo "last_tag=$prod_latest_tag" >> "$GITHUB_OUTPUT"
          fi
          
          echo "next_patch=$prod_next_patch" >> "$GITHUB_OUTPUT"
          echo "Next prod patch: $prod_next_patch"
          
          if [ -z "$VARIANT" ]; then
            # Prod tag
            new_tag="${BASE}.${prod_next_patch}"
            echo "new_tag=$new_tag" >> "$GITHUB_OUTPUT"
            echo "is_prod=true" >> "$GITHUB_OUTPUT"
            echo "Generated prod tag: $new_tag"
          else
            # Variant tag
            variant_prefix="${BASE}.${prod_next_patch}-${VARIANT}"
            existing=$(git tag --list "${variant_prefix}*" | sort -V || true)
            
            if [ -z "$existing" ]; then
              idx=1
            else
              max=0
              while read -r t; do
                num=$(echo "$t" | sed -E "s/^${BASE}\.${prod_next_patch}-${VARIANT}([0-9]+)$/\1/")
                if [[ "$num" =~ ^[0-9]+$ ]]; then
                  if [ "$num" -gt "$max" ]; then
                    max=$num
                  fi
                fi
              done <<< "$existing"
              idx=$((max + 1))
            fi
            
            new_tag="${BASE}.${prod_next_patch}-${VARIANT}${idx}"
            echo "new_tag=$new_tag" >> "$GITHUB_OUTPUT"
            echo "is_prod=false" >> "$GITHUB_OUTPUT"
            echo "Generated variant tag: $new_tag"
          fi

      - name: Check for changes since last release
        id: changes
        shell: bash
        env:
          LAST_TAG: ${{ steps.version.outputs.last_tag }}
          SRC_REF: ${{ steps.branch.outputs.source_ref }}
          SKIP_IF_NO_CHANGES: ${{ github.event.inputs.skip_if_no_changes || 'true' }}
        run: |
          set -euo pipefail
          
          if [ "$SKIP_IF_NO_CHANGES" != "true" ]; then
            echo "skip_check=false" >> "$GITHUB_OUTPUT"
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            echo "Skipping change detection (skip_if_no_changes=false)"
            exit 0
          fi
          
          if [ -z "$LAST_TAG" ]; then
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            echo "skip_check=false" >> "$GITHUB_OUTPUT"
            echo "No previous release found, proceeding with first release"
            exit 0
          fi
          
          # Count commits since last tag on this branch
          commit_count=$(git rev-list --count "${LAST_TAG}..${SRC_REF}" || echo "0")
          
          echo "Commits since $LAST_TAG: $commit_count"
          
          if [ "$commit_count" -eq 0 ]; then
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            echo "skip_check=true" >> "$GITHUB_OUTPUT"
            echo "âš ï¸ No changes detected since last release. Skipping release creation."
          else
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            echo "skip_check=false" >> "$GITHUB_OUTPUT"
            echo "âœ… Found $commit_count new commit(s) since last release"
          fi

      - name: Skip release (no changes)
        if: steps.changes.outputs.skip_check == 'true'
        run: |
          echo "::notice::No changes since last release. Skipping release creation."
          exit 0

      - name: Generate changelog
        if: steps.changes.outputs.has_changes == 'true'
        id: changelog
        shell: bash
        env:
          LAST_TAG: ${{ steps.version.outputs.last_tag }}
          NEW_TAG: ${{ steps.version.outputs.new_tag }}
          SRC_REF: ${{ steps.branch.outputs.source_ref }}
        run: |
          set -euo pipefail
          
          if [ -z "$LAST_TAG" ]; then
            range="${SRC_REF}"
            echo "Generating changelog for all commits on ${SRC_REF}"
          else
            range="${LAST_TAG}..${SRC_REF}"
            echo "Generating changelog for ${range}"
          fi
          
          # Create changelog with categorized commits
          changelog_file=$(mktemp)
          
          # Features
          features=$(git log "$range" --pretty=format:"- %s (%h)" --grep="^feat" --grep="^feature" -i || true)
          
          # Bug fixes
          fixes=$(git log "$range" --pretty=format:"- %s (%h)" --grep="^fix" -i || true)
          
          # Documentation
          docs=$(git log "$range" --pretty=format:"- %s (%h)" --grep="^docs" -i || true)
          
          # Other changes
          others=$(git log "$range" --pretty=format:"- %s (%h)" --invert-grep --grep="^feat" --grep="^feature" --grep="^fix" --grep="^docs" -i || true)
          
          # Build changelog file
          {
            echo "## What's Changed"
            echo ""
            
            if [ -n "$features" ]; then
              echo "### âœ¨ Features"
              echo "$features"
              echo ""
            fi
            
            if [ -n "$fixes" ]; then
              echo "### ðŸ› Bug Fixes"
              echo "$fixes"
              echo ""
            fi
            
            if [ -n "$docs" ]; then
              echo "### ðŸ“š Documentation"
              echo "$docs"
              echo ""
            fi
            
            if [ -n "$others" ]; then
              echo "### ðŸ”§ Other Changes"
              echo "$others"
              echo ""
            fi
            
            if [ -n "$LAST_TAG" ]; then
              echo "---"
              echo ""
              echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${LAST_TAG}...${NEW_TAG}"
            fi
          } > "$changelog_file"
          
          # Output changelog
          changelog_content=$(cat "$changelog_file")
          {
            echo "changelog<<EOF"
            echo "$changelog_content"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          
          echo "Generated changelog:"
          cat "$changelog_file"

      - name: Create and push tag
        if: steps.changes.outputs.has_changes == 'true'
        shell: bash
        env:
          NEW_TAG: ${{ steps.version.outputs.new_tag }}
        run: |
          git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
          git push origin "refs/tags/$NEW_TAG"
          echo "âœ… Created and pushed tag: $NEW_TAG"

      - name: Create GitHub Release
        if: steps.changes.outputs.has_changes == 'true'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.new_tag }}
          release_name: Release ${{ steps.version.outputs.new_tag }}
          body: ${{ steps.changelog.outputs.changelog }}
          draft: false
          prerelease: ${{ steps.version.outputs.is_prod != 'true' }}

      - name: Release summary
        if: steps.changes.outputs.has_changes == 'true'
        run: |
          {
            echo "### ðŸŽ‰ Release Created Successfully!"
            echo ""
            echo "**Tag:** ${{ steps.version.outputs.new_tag }}"
            echo "**Type:** ${{ steps.version.outputs.is_prod == 'true' && 'Production' || 'Pre-release' }}"
            echo "**Branch:** ${{ steps.branch.outputs.source_ref }}"
            echo ""
            echo "[View Release](https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.new_tag }})"
          } >> "$GITHUB_STEP_SUMMARY"
